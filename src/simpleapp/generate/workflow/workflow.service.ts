/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-04-15
 * Author: Ks Tan
 */
import { WorkflowConfig } from './workflow.config';
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  Logger,
  NotFoundException,
} from '@nestjs/common';
import {
  WorkflowSettingApiSchema,
  WorkflowDataApiSchema,
  WorkflowProcess,
  WorkflowTask,
  UserTaskActors,
  UserTaskType,
  ServiceTaskData,
  UserTaskData,
  UserTaskEventType,
  ServiceTaskEventType,
} from './workflow.type';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import {
  BPMNServer,
  Logger as bpmnlogger,
  BPMN_TYPE,
  EXECUTION_EVENT,
} from 'bpmn-server';
// import { configuration } from './configuration';
import { UserContext } from '../commons/user.context';
import { WorkflowName } from '../types';
//import * as formschemas from '../../workflow/formschema';
export {
  WorkflowSettingApiSchema,
  WorkflowDataApiSchema,
} from './workflow.type';

@Injectable()
export class WorkflowService {
  protected bpmnServer: BPMNServer;
  private readonly logger = new Logger();
  constructor(
    private workflowconfig: WorkflowConfig,
    private eventEmitter: EventEmitter2,
  ) {
    this.bpmnServer = new BPMNServer(this.workflowconfig.getConfig());
    this.bpmnServer.listener.on(
      'all',
      async (event) => await this.applyEventListener(event),
    );
  }

  /**
   * get all workflow userTask for specific uid (uuid)
   * @param appuser
   * @returns array of usertask
   */
  async getActorUserTask(appuser: UserContext, uid: string) {
    const tmp: any[] = await this.bpmnServer.dataStore.findItems({
      'items.status': 'wait',
      'data.tenantId': appuser.getTenantId(),
      //filter uid properties base on function
      $or: [
        { 'items.assignee': appuser.getUname() },
        { 'items.candidateUsers': appuser.getUname() },
        { 'items.candidateGroups': appuser.getGroups() },
      ],
    });
    const result: UserTaskType[] = tmp.map((proc) => {
      const subitem: UserTaskType = {
        id: proc.instanceId,
        taskId: proc.id,
        elementId: proc.elementId,
        name: proc.name,
        processName: proc.processName,
        assignee: proc.assignee,
        candidateUsers: proc.candidateUsers,
        candidateGroups: proc.candidateGroups,
        data: proc.data,
        vars: proc.vars,
        startedAt: proc.startedAt,
        followUpDate: proc.followUpDate,
        dueDate: proc.dueDate,
        priority: proc.priority,
        type: proc.type,
        userId: proc.userId,
      };
      return subitem;
    });
    return result;
    // throw new BadRequestException(`getActorUserTask is not supported yet`)
  }
  /**
   * get all workflow userTask for my uid (uuid)
   * @param appuser
   * @returns array of usertask
   */
  async getMyUserTask(appuser: UserContext) {
    return await this.getActorUserTask(appuser, appuser.getUid());
  }

  /**
   * !! waiting founder
   * deveploper method
   * create new process definitions
   */
  async newWorkflowDefinitions(
    appuser: UserContext,
    workflowName: WorkflowName,
    xml: string,
  ) {
    throw new BadRequestException(
      `newWorkflowDefinitions "${workflowName}" is not supported yet`,
    );
  }

  async getWorkflowDefinitions(appuser: UserContext) {
    throw new BadRequestException(
      `getWorkflowDefinitions is not supported yet`,
    );
  }

  async readWorkflowDefinition(
    appuser: UserContext,
    workflowname: WorkflowName,
  ) {
    throw new BadRequestException(
      `readWorkflowDefinition is not supported yet`,
    );
  }

  async deleteWorkflowDefinition(
    appuser: UserContext,
    workflowname: WorkflowName,
  ) {
    throw new BadRequestException(
      `deleteWorkflowDefinition is not supported yet`,
    );
  }

  async updateWorkflowDefinition(
    appuser: UserContext,
    workflowname: WorkflowName,
    xml: string,
  ) {
    throw new BadRequestException(
      `updateWorkflowDefinition is not supported yet`,
    );
  }

  /**
   * admin workflow service, obtain all active workflows and it's pending task from all tenant
   * status: done
   * @param appuser
   * @returns array of workflow process and it's waiting task
   */
  async getAllActiveProcesses(appuser: UserContext) {
    const alldata = await this.bpmnServer.dataStore.findInstances(
      { status: 'running' },
      'summary',
    );
    const result = this.workflowProcessArrayMaping(alldata);
    return result;
  }

  /**
   * delete a workflow process from database
   * @param appuser
   * @param id
   * @returns
   */
  async deleteWorkflowById(appuser: UserContext, id: string) {
    if (await this.getWorkflowById(appuser, id)) {
      const result = await this.bpmnServer.dataStore.deleteInstances({
        id: id,
      });
      return {
        status: 'ok',
        deletedCount: result['deletedCount'],
      };
    }
  }

  /**
   * invoke workflow process to next step
   * @param appuser
   * @param id
   * @param taskId
   * @param data
   * @returns
   */
  async invokeWorkflowUserTask(
    appuser: UserContext,
    taskId: string,
    data: any,
  ) {
    try {
      const response = await this.bpmnServer.engine.invoke(
        { 'items.id': taskId, 'items.status': 'wait' },
        data,
        appuser.getUid(),
        { appuser: appuser },
      );
      return {
        parentKeys: Object.keys(response),
        parentId: response.id,
        data: response.instance.data,
        // parentId:response,
        input: response.item.input,
        vars: response.item.vars,
        id: response.item.id,
        status: response.item.status,
      };
    } catch (e) {
      throw new NotFoundException(e);
    }
  }

  /**
   * !! waiting founder
   * use in adhoc situation override bpmn assignee/candidateUsers/Groups with data
   * status: draft
   * @param appuser
   * @param id
   * @param taskId
   * @param data
   */
  async updateWorkflowUserTask(
    appuser: UserContext,
    id: string,
    taskId: string,
    assignmentdata: UserTaskActors,
  ) {
    try {
      const result = await this.bpmnServer.dataStore.findInstance(
        { id: id },
        {},
      );

      const usertask = result.items.find((item) => item.id == taskId);
      if (usertask) {
        const result = await this.bpmnServer.engine.assign(
          { id: id, 'items.id': taskId },
          { newData: 1 }, //some data want to put in
          assignmentdata,
          appuser.getUid(),
          {}, //options
        );
        return 'OK'; //Object.keys(result)
      } else {
        throw new NotFoundException(`user task id:${taskId} not found`);
      }
    } catch (e) {
      throw new NotFoundException(e);
    }

    // throw new BadRequestException(`updateWorkflowUserTask is not supported yet`)
  }

  /**
   *
   * @param appuser search all workflow in current tenant
   * @param filter
   * @returns
   */
  async searchRunningWorkflowProcesses(appuser: UserContext, filter: any) {
    // filter['data.tenantId']= appuser.getTenantId()  //tmp disabled waiting
    filter['status'] = 'running';
    return await this.searchWorkflowProcesses(appuser, filter);
  }

  /**
   *
   * @param appuser search all workflow in current tenant
   * @param filter
   * @returns
   */
  async searchWorkflowProcesses(appuser: UserContext, filter: any) {
    filter['data.tenantId'] = appuser.getTenantId(); //tmp disabled waiting
    const alldata = await this.bpmnServer.dataStore.findInstances(
      filter,
      'summary',
    );
    const result = this.workflowProcessArrayMaping(alldata);
    return result;
  }

  async getPendingProcess(appuser: UserContext) {
    const tmp: any[] = await this.bpmnServer.dataStore.findItems({
      'items.status': 'wait',
    });

    const result = tmp.map((proc) => ({
      id: proc.instanceId,
      assignee: proc.assignee,
      candidateUsers: proc.candidateUsers,
      candidateGroups: proc.candidateGroups,
      data: proc.data,
      processName: proc.processName,
      startedAt: proc.startedAt,
      type: proc.type,
      taskName: proc.name,
      userId: proc.userId,
    }));
    return result;
  }

  /**
   * initialise new workflow process, also listening event 'workflow.start'
   * status: done
   * @param appuser
   * @param workflowName
   * @param data
   * @returns workflowsummary
   */
  @OnEvent('workflow.start')
  async startWorkflow(
    appuser: UserContext,
    workflowName: WorkflowName,
    data?: any,
  ) {
    //run as event, it wont have transaction
    appuser.setDBSession(undefined);
    
    if (!data ) data = {}    
    
    //sometimes data is Mongoose object instead of pure data, need serialize and deserialize to remove that
    data=JSON.parse(JSON.stringify(data))
    
    try {
      // console.log('startWorkflow started: ', workflowName);
      
      data.tenantId = appuser.getTenantId();
      data.orgId = appuser.getOrgId();
      data.branchId = appuser.getBranchId();
    
      const result = await this.bpmnServer.engine.start(
        workflowName,
        data,
        undefined,
        appuser.getUid(),
        {
          appuser: appuser,
        },
      );

      // console.log("startWorkflowstartWorkflowstartWorkflow",result)
      return {
        id: result.id,
        name: result.name,
        status: result.status,
        userId: result.userName,
        startedAt: result.item.startedAt,
      };
    } catch (e) {
      throw new BadRequestException(e, JSON.stringify(data));
    }
  }

  /**
   * read single process full property
   * @param appuser
   * @param id
   * @returns
   */
  async getWorkflowById(appuser: UserContext, id: string) {
    try {
      const data = await this.bpmnServer.dataStore.findInstance({ id: id }, {}); // .findInstances({id:id},'full')
      const result = this.workflowProcessMaping(data);
      return result;
    } catch (e) {
      throw new NotFoundException(e);
    }
  }
  async getPendingWorkflows(appuser: UserContext) {
    const tmp: any[] = await this.bpmnServer.dataStore.findItems({
      'items.status': 'wait',
    });

    const result = tmp.map((proc) => ({
      id: proc.instanceId,
      assignee: proc.assignee,
      candidateUsers: proc.candidateUsers,
      candidateGroups: proc.candidateGroups,
      data: proc.data,
      processName: proc.processName,
      startedAt: proc.startedAt,
      type: proc.type,
      taskName: proc.name,
      userId: proc.userId,
    }));
    return result;
  }

  /**
   * obtain specific bpmn task camunda:formKey
   * @param appuser
   * @param processName
   * @param elementId
   * @returns properties
   */
  async getWorkflowUserTaskFormKey(
    appuser,
    processName: string,
    elementId: string,
  ) {
    try {
      let definition = await this.bpmnServer.definitions.load(processName);
      let node = definition.getNodeById(elementId);
      if (node) {
        const formKey = node.def.formKey;
        let schema: string = node.def.formKey;

        if (schema) {
          return {
            processName: processName,
            elementId: elementId,
            schema: schema,
          };
        } else {
          throw new InternalServerErrorException(
            `Cannot resolve schema from invalid formKey '${schema}', example: 'jsonschema://SimpleApproveReject' or 'custom://your-custom-key'`,
          );
        }
      } else {
        throw new NotFoundException(
          `Element ${elementId} not found in process ${processName}`,
        );
      }
    } catch (e) {
      throw new InternalServerErrorException(e);
    }
  }

  // helper
  workflowProcessArrayMaping(alldata: any[]) {
    const result = alldata.map((data) => this.workflowProcessMaping(data));
    return result;
  }
  workflowProcessMaping(data: any) {
    const result: WorkflowProcess = {
      id: data.id,
      name: data.name,
      status: data.status,
      startedAt: data.startedAt,
      items: data.items
        .filter((item) => item.type != 'bpmn:SequenceFlow')
        .map((item) => ({
          taskId: item.id,
          name: item.name,
          status: item.status,
          assignee: item.assignee,
          candidateUsers: item.candidateUsers,
          candidateGroups: item.candidateGroups,
          type: item.type,
        })),
    };
    return result;
  }

  /**
   * listen all events in bpmn-server engine, inclduded task and execution instances
   * @param event bpmn-server event instance
   */
  async applyEventListener(event) {
    if (event.context.item) {
      const workflowName: string = event.context.instance.name;
      const eventType: EXECUTION_EVENT = event.event;
      const elementType: BPMN_TYPE = event.context.item.element.type;
      const elementId: string = event.context.item.element.id;
      const elementName: string = event.context.item.element.name;
      const elementProps = event.context.item.element.def;
      // const usertaskinput = event.context.item.input ?? null;
      const data = event.context.instance.data;
      const vars = {};
      Object.assign(vars, event.context.item.input);
      event.context.item.input = {};
      const options = event.context.options;
      switch (elementType) {
        case BPMN_TYPE.UserTask:
          let usertaskeventtype: UserTaskEventType;
          if (eventType == EXECUTION_EVENT.node_start)
            usertaskeventtype = 'start';
          else if (eventType == EXECUTION_EVENT.node_assign)
            usertaskeventtype = 'assign';
          else if (eventType == EXECUTION_EVENT.node_end)
            usertaskeventtype = 'end';
          else if (eventType == EXECUTION_EVENT.transform_input)
            usertaskeventtype = 'invoked';
          else if (eventType == EXECUTION_EVENT.node_wait)
            usertaskeventtype = 'wait';
          // console.log("event-------=================================",eventType,usertaskeventtype)
          if (usertaskeventtype) {
            const props: UserTaskData = {
              workflowName: workflowName,
              eventType: usertaskeventtype,
              elementType: 'bpmn:UserTask',
              elementId: elementId,
              elementName: elementName,
              elementProps: {
                startedAt: event.context.item.startedAt,
                assignee: event.context.item.assignee,
                candidateGroups: event.context.item.candidateGroups,
                candidateUsers: event.context.item.candidateUsers,
                dueDate: event.context.item.dueDate,
                followUpDate: event.context.item.followUpDate,
                priority: event.context.item.priority,
                formKey: elementProps.formKey,
              },
              data: data,
              vars: vars,
              options: options,
            };
            this.eventEmitter.emit(
              `${workflowName}.${elementId}.${usertaskeventtype}`,
              props,
            );
          }

          break;
        case BPMN_TYPE.ServiceTask:
          let servicetaskeventtype: ServiceTaskEventType;
          if (eventType == EXECUTION_EVENT.node_start)
            servicetaskeventtype = 'start';
          else if (eventType == EXECUTION_EVENT.node_end)
            servicetaskeventtype = 'end';
          if (servicetaskeventtype) {
            const props: ServiceTaskData = {
              workflowName: workflowName,
              eventType: servicetaskeventtype,
              elementType: 'bpmn:ServiceTask',
              elementId: elementId,
              elementName: elementName,
              data: data,
              vars: vars,
              options: options,
            };
            this.eventEmitter.emit(
              `${workflowName}.${elementId}.${servicetaskeventtype}`,
              props,
            );
          }
          break;
        default: //do nothing at the moment
          break;
      }
    }
  }
}
