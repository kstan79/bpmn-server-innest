/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import { UserContext } from './user.context';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { DocNumberFormatResult } from '../types';
import { Docnoformat } from '../types/docno.type';
import {
  Injectable,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import moment from 'moment';
import { ForeignKey } from '../types';

export class DocNumberFormatGenerator {
  constructor(
    @InjectModel('Docnoformat') private docformat: Model<Docnoformat>,
  ) {}

  async generateNextNumberFromDocument(
    appuser: UserContext,
    docType: string,
    data: any,
  ) {
    let formatId = '';
    if (data.docNoFormat && data.docNoFormat._id) {
      formatId = data.docNoFormat._id;
    }
    const docnoobj = await this.generateNextNo(appuser, docType, formatId);
    const result: ForeignKey = {
      _id: String(docnoobj.formatId),
      label: docnoobj.formatName,
    };
    data.docNoFormat = result;
    return docnoobj.result;
  }

  generateNextNo = async (
    appuser: UserContext,
    doctype: string,
    id: string = '',
  ) => {
    doctype = doctype.toUpperCase();
    let filter = { docNoType: doctype };
    if (id) {
      filter['_id'] = id;
    }
    Object.assign(filter, appuser.getBranchFilter());
    const result = await this.docformat.find(filter);
    //search(appuser, filter);
    if (result && result.length > 0) {
      const d: Docnoformat = result[0];
      const recordId = d._id;
      const newdocno = DocNumberFormatGenerator.previewDocNo(d);
      const newnextnumber = d.nextNumber + 1;
      const updatedata = { nextNumber: newnextnumber } as Docnoformat;
      const updateresult = await this.docformat
        .findByIdAndUpdate(recordId, updatedata)
        .session(appuser.getDBSession());

      if (updateresult) {
        const result: DocNumberFormatResult = {
          formatId: d._id,
          formatName: d.docNoFormatName,
          result: newdocno,
        };
        return result;
        //;
      } else {
        throw new InternalServerErrorException(
          `Update document format ${doctype}/${recordId} to next number (${newnextnumber}) failed`,
        );
      }
    } else {
      throw new BadRequestException(
        `invalid parameter doctype: "${doctype}" or id: ${id}`,
      );
    }
  };
  static previewDocNo = (s: Docnoformat) => {
    try {
      const pattern = s.docNoPattern;
      const numberReg: RegExp = /\[(.*?)\]/g;
      const dateReg: RegExp = /\{(.*?)\}/g;
      let newvalue = pattern;
      const numberpattern: string[] = pattern.match(numberReg);
      const datepattern: string[] = pattern.match(dateReg);

      if (numberpattern && numberpattern.length > 0) {
        const numberlength = numberpattern[0]
          .replace('[', '')
          .replace(']', '').length;

        let nextnumber = s.nextNumber.toString();

        const numberdiff = numberlength - nextnumber.length;

        for (let n = 0; n < numberdiff; n++) {
          nextnumber = '0' + nextnumber;
        }
        newvalue = newvalue.replace(numberpattern[0], nextnumber);
      }

      if (datepattern && datepattern.length > 0) {
        for (let d = 0; d < datepattern.length; d++) {
          const dpattern = datepattern[d];
          const date = new Date();
          const formatteddate = moment().format(
            dpattern.replace('{', '').replace('}', ''),
          );
          newvalue = newvalue.replace(dpattern, formatteddate);
        }
      }
      return newvalue;
    } catch (e) {
      const errors = `Format ${s.docNoFormatName} error ${e}`;
      throw new InternalServerErrorException(errors);
    }
  };
}
