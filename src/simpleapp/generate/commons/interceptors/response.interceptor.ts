/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  BadGatewayException,
  HttpException,
} from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { Model, Connection, ClientSession } from 'mongoose';
import { InjectConnection, InjectModel } from '@nestjs/mongoose';
import { UserContext } from '../user.context';
import { ApiEvent } from '../../types';
@Injectable()
export class ResponseInterceptor implements NestInterceptor {
  constructor(
    @InjectConnection() private readonly connection: Connection,
    @InjectModel('ApiEvent') private apieventmodel: Model<ApiEvent>,
  ) {}

  async intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Promise<Observable<any>> {
    const req = context.switchToHttp().getRequest();
    const resp = context.switchToHttp().getResponse();
    const usersession: UserContext = req['sessionuser'];

    const method = req['method'];
    const headers = { ...req['headers'] };
    const ip = req['ip'];
    const url = req['url'];
    // let { url, method, headers, body }
    const session = await this.connection.startSession();
    if (!session['runCount']) {
      session['runCount'] = 0;
    } else {
      session['runCount'] = session['runCount'] + 1;
    }
    usersession.setDBSession(session);
    // const session: ClientSession = usersession.getDBSession();
    const logid: string = crypto.randomUUID();
    const starttime = new Date();
    let canCommit = true;
    //authorization no need
    delete headers['authorization']; //='--removed--'
    const eventdata: ApiEvent = {
      _id: logid,
      created: starttime.toISOString(),
      duration: 0,
      createdBy: usersession.getUid(),
      path: url,
      method: method,
      headers: headers,
      ip: ip,
      // data: req.body,
      statusCode: 0,
      status: 'D',
    };
    const eventmodel = new this.apieventmodel(eventdata);

    const eventObj = await eventmodel.save();

    // req['eventObj'] = eventObj;
    return next.handle().pipe(
      catchError(async (err, caught) => {
        // console.log('**************catchError at interceptor ',method,url)
        if (session.inTransaction()) {
          await session.abortTransaction();
          canCommit = false;
        }

        const responseBody = {
          message: err.message,
          timestamp: new Date().toISOString(),
          path: url,
          error: err.options,
        };

        // eventObj.statusCode = err.status;
        // eventObj.errMsg = responseBody.message;
        // const endtime = new Date();
        // eventObj.updated = endtime.toISOString();
        // eventObj.data = req.body;
        // eventObj.errData = responseBody.error;
        // eventObj.status = 'NG';
        // eventObj.duration =
        // endtime.getTime() - new Date(eventObj.created).getTime();
        // eventObj.save();

        resp.status(err.status);
        return responseBody;
      }),
      tap(async () => {
        // console.log("============interceptor tap",method,url)
        const endtime = new Date();
        eventObj.isNew = false;
        eventObj.statusCode = resp['statusCode'];
        eventObj.updated = endtime.toISOString();
        eventObj.status = 'OK';
        eventObj.duration = endtime.getTime() - starttime.getTime();
        await eventObj.save();

        if (process.env.DRYRUN == 'true') {
          console.warn('--------dryrun! roll back everything-----------');
          if (session.inTransaction() && canCommit) {
            await session.abortTransaction();
          }
        } else {
          if (session.inTransaction() && canCommit) {
            await session.commitTransaction(); //.then(()=>session.endSession());
          }
        }
        // session.endSession()
      }),
    );
  }
}
